# Deployment & Maintenance Guide — React + Node + Python (Streamlit)

Compact, practical, and ready-to-use. Assumes a Linux server (Debian/Ubuntu) with Docker & Docker Compose installed, `git` and a domain pointed via DNS. Keep secrets in `.env` or a vault.

---

# 1. Basic setup steps

1. **Prepare code**

   * React: `npm run build` produces `build/` (static).
   * Node: serve API on `PORT` (use `process.env.PORT`). Use PM2 for local dev/zero-downtime restarts.
   * Streamlit: `streamlit run app.py --server.port $PORT --server.address 0.0.0.0`.

2. **Containerize** — create Docker images for each service (examples below).

3. **Compose or Orchestrate** — use `docker-compose` for small deployments or Kubernetes for production.

4. **Reverse proxy & TLS** — Nginx + Certbot (Let's Encrypt) to route domain to services and terminate TLS.

5. **Monitoring & Logs** — `docker logs`, `journalctl`, Prometheus + Grafana or hosted monitoring.

6. **Backups & Secrets** — store DB backups and secrets (HashiCorp Vault, AWS Secrets Manager, or env files).

7. **Healthchecks** — app `/health` endpoints, container `HEALTHCHECK` in Dockerfile.

8. **CI/CD** — pipeline to build images, run tests, push to registry, and deploy (GitHub Actions / GitLab CI).

---

# 2. Example Dockerfiles

### React (NGINX serve static)

```Dockerfile
# frontend/Dockerfile
FROM node:20-alpine AS builder
WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build

FROM nginx:1.25-alpine
COPY --from=builder /app/build /usr/share/nginx/html
COPY ./nginx/frontend.conf /etc/nginx/conf.d/default.conf
EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
```

### Node (Express + PM2 optional inside container)

```Dockerfile
# backend/Dockerfile
FROM node:20-alpine
WORKDIR /usr/src/app
COPY package*.json ./
RUN npm ci --production
COPY . .
ENV NODE_ENV=production
EXPOSE 3000
CMD ["node", "dist/index.js"]  # or: ["pm2-runtime", "ecosystem.config.js"]
```

### Streamlit (Python)

```Dockerfile
# streamlit/Dockerfile
FROM python:3.11-slim
WORKDIR /app
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt
COPY . .
ENV PYTHONUNBUFFERED=1
ENV STREAMLIT_SERVER_HEADLESS=true
EXPOSE 8501
CMD ["streamlit", "run", "app.py", "--server.port", "8501", "--server.address", "0.0.0.0"]
```

---

# 3. Example docker-compose (multi-service)

```yaml
version: "3.8"
services:
  nginx:
    image: nginx:1.25-alpine
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - ./certs:/etc/letsencrypt
    ports:
      - "80:80"
      - "443:443"
    depends_on:
      - frontend
      - backend
      - streamlit

  frontend:
    build: ./frontend
    restart: unless-stopped

  backend:
    build: ./backend
    environment:
      - PORT=3000
      - DATABASE_URL=${DATABASE_URL}
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000/health"]
      interval: 30s
      timeout: 5s
      retries: 3

  streamlit:
    build: ./streamlit
    environment:
      - PORT=8501
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8501/health"]
      interval: 30s
      timeout: 5s
      retries: 3
```

---

# 4. Nginx reverse-proxy (example)

Place this as `/etc/nginx/conf.d/app.conf` or in compose volume.

```nginx
server {
    listen 80;
    server_name example.com www.example.com;
    # Redirect to https
    return 301 https://$host$request_uri;
}

server {
    listen 443 ssl http2;
    server_name example.com www.example.com;

    ssl_certificate /etc/letsencrypt/live/example.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/example.com/privkey.pem;

    # React static
    location / {
        proxy_pass http://frontend:80;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }

    # API
    location /api/ {
        rewrite ^/api(/.*)$ $1 break;
        proxy_pass http://backend:3000/;
        proxy_http_version 1.1;
        proxy_set_header Connection "";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }

    # Streamlit app (mounted at /viz)
    location /viz/ {
        proxy_pass http://streamlit:8501/;
        proxy_set_header Host $host;
        proxy_buffering off;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}
```

> For Streamlit, you may need `baseUrlPath` handling or a subdomain to avoid path issues.

---

# 5. Simple deployment script (server-side)

```bash
#!/usr/bin/env bash
set -euo pipefail
cd /opt/myapp
git pull origin main
docker-compose pull
docker-compose build --pull
docker-compose up -d --remove-orphans
docker-compose ps
# optional: remove dangling images
docker image prune -f
```

Store as `/usr/local/bin/deploy-myapp` and run from CI agent via SSH.

---

# 6. Common troubleshooting & fixes

* **404 or wrong assets**: Ensure React `homepage` is set correctly or that Nginx serves from `/usr/share/nginx/html`. Clear browser cache.
* **502/504 proxy errors**: Backend crashed or wrong upstream port. `docker-compose logs backend`; check healthcheck endpoint.
* **Streamlit path issues**: Streamlit doesn't natively support sub-paths; use a subdomain or set `browser.serverAddress` and `baseUrlPath` (but subdomain is simpler).
* **SSL errors**: Certbot not renewing — check `certbot renew --dry-run` and permissions on `/etc/letsencrypt`.
* **High memory / OOM**: Check `docker stats` and app memory usage. Increase server RAM, tune Node heap (`--max-old-space-size`), or add swap.
* **DB connection refused**: Check firewall, environment variables, and network (`docker network ls`, `docker inspect`).

---

# 7. Log monitoring commands

* **Docker**:

  * `docker-compose logs -f backend` (follow logs)
  * `docker logs -f --tail 200 backend_container_id`
  * `docker ps --format '{{.Names}}\t{{.Status}}'`
* **Systemd (if used)**:

  * `sudo journalctl -u nginx -f`
  * `sudo journalctl -u docker -f`
* **Host-level**:

  * `top` / `htop`
  * `df -h` (disk usage)
  * `ss -tulpn` or `netstat -tulpn`
* **Aggregate/long-term**: use ELK/EFK (Elasticsearch/Fluentd/Kibana) or Loki + Grafana.
* **Quick grep**:

  * `docker-compose logs --no-color backend | grep -i "error"`

---

# 8. Self-healing & restart tips

* **Docker restart policies**:

  ```yaml
  restart: unless-stopped   # or always, on-failure:5
  ```
* **Healthchecks**: use `HEALTHCHECK` in Dockerfile or compose healthcheck. If unhealthy, orchestrator can restart.

  ```dockerfile
  HEALTHCHECK --interval=30s --timeout=5s --retries=3 CMD curl -f http://localhost:3000/health || exit 1
  ```
* **Process manager**: use `pm2-runtime` inside Node container for graceful restarts and process monitoring:

  ```json
  // ecosystem.config.js - start with pm2-runtime
  ```
* **Watchtower / Auto-update**: run [Watchtower] to pull new images and restart containers when images update (beware auto-updating DB containers).
* **systemd service**: wrap `docker-compose` in a systemd unit to restart on failure.
* **Circuit breaker & rate-limits**: implement in Node or use API gateway to prevent cascading failures.
* **Graceful shutdown**: handle `SIGTERM` in Node/Streamlit to close DB connections before exit.

---

# 9. Helpful extras / quick checklist

* Add `/health` returning 200 for each service.
* Add logging (structured JSON) and correlation IDs for tracing.
* Rotate logs & monitor disk space.
* Automate DB backups and test restores monthly.
* Use environment-specific configs (dev/staging/prod).
* Use least-privilege service accounts for cloud resources.

---

# 10. Quick security reminders

* Do **not** store secrets in Git. Use environment variables, Docker secrets, or secret managers.
* Keep images updated: base image patching, rebuild monthly.
* Use a web application firewall (Cloudflare or Nginx ModSecurity) and rate limit `/login`.

---

If you want, I can:

* produce a ready-to-run `docker-compose.yml` wired to your repo structure,
* or a systemd unit + certbot commands for Let's Encrypt automation,
* or a compact GitHub Actions workflow to build and deploy images.
